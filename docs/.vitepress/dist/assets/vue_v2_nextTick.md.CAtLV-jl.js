import{_ as i,c as t,o as l,ag as a}from"./chunks/framework.DPDPlp3K.js";const h=JSON.parse('{"title":"异步队列更新原理","description":"","frontmatter":{},"headers":[],"relativePath":"vue/v2/nextTick.md","filePath":"vue/v2/nextTick.md","lastUpdated":null}'),o={name:"vue/v2/nextTick.md"};function n(r,e,u,c,s,d){return l(),t("div",null,e[0]||(e[0]=[a('<h1 id="异步队列更新原理" tabindex="-1">异步队列更新原理 <a class="header-anchor" href="#异步队列更新原理" aria-label="Permalink to &quot;异步队列更新原理&quot;">​</a></h1><h2 id="_1、vue2的异步更新队列如何工作" tabindex="-1">1、Vue2的异步更新队列如何工作？ <a class="header-anchor" href="#_1、vue2的异步更新队列如何工作" aria-label="Permalink to &quot;1、Vue2的异步更新队列如何工作？&quot;">​</a></h2><p>Vue 将数据变更触发的 Watcher 更新存入队列（queueWatcher），通过 nextTick 延迟执行批处理，避免重复计算。</p><ul><li>设计目标 <ul><li>批量更新： <code>合并同一事件循环中的所有数据变更进行批量更新</code></li><li>避免重复渲染：防止频繁数据变更导致的无效渲染</li><li>保证更新顺序：确保组件更新按父→子的合理顺序执行</li><li>性能优化：利用微任务减少UI线程阻塞</li></ul></li><li>异步更新优势 <ul><li>连续多次修改，只会触发一次更新</li></ul></li></ul><h2 id="_2、nexttick的实现原理是什么" tabindex="-1">2、nextTick的实现原理是什么？ <a class="header-anchor" href="#_2、nexttick的实现原理是什么" aria-label="Permalink to &quot;2、nextTick的实现原理是什么？&quot;">​</a></h2><ul><li>收集所有修改内容，但不会立即更新</li><li>把更新任务放进一个&quot;待办事项列表&quot;</li><li>安排一个最快的调度去执行 <code>选择一个最快的送货方式</code><ul><li>首选快递（微任务）​：Promise.then （外卖小哥）</li><li>备选快递（微任务）​：MutationObserve (同城快递)</li><li>普通快递（宏任务）​：setTimeout (邮政快递)</li></ul></li></ul><p><strong>nextTick执行时机</strong></p><p>在当前同步代码执行完后，在所有微任务之前，DOM已经更新完成</p><ul><li>与Promise的区别：nextTick回调比Promise.then更早执行</li><li>与setTimeout的区别：比所有宏任务都早执行</li></ul>',9)]))}const p=i(o,[["render",n]]);export{h as __pageData,p as default};
