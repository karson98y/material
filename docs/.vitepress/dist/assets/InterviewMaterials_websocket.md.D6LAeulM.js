import{_ as i,c as a,o as t,ag as n}from"./chunks/framework.DPDPlp3K.js";const o=JSON.parse('{"title":"Websocket 常见面试题","description":"","frontmatter":{},"headers":[],"relativePath":"InterviewMaterials/websocket.md","filePath":"InterviewMaterials/websocket.md","lastUpdated":1743559453000}'),h={name:"InterviewMaterials/websocket.md"};function e(l,s,k,p,r,d){return t(),a("div",null,s[0]||(s[0]=[n(`<h1 id="websocket-常见面试题" tabindex="-1">Websocket 常见面试题 <a class="header-anchor" href="#websocket-常见面试题" aria-label="Permalink to &quot;Websocket 常见面试题&quot;">​</a></h1><p>WebSocket 是一种基于 ​TCP 的 ​全双工通信协议，用于在 ​单个持久连接 上实现客户端（如浏览器）和服务端之间的 ​低延迟双向数据交换。</p><h2 id="websocket-建立连接都有哪些步骤" tabindex="-1">Websocket 建立连接都有哪些步骤 <a class="header-anchor" href="#websocket-建立连接都有哪些步骤" aria-label="Permalink to &quot;Websocket 建立连接都有哪些步骤&quot;">​</a></h2><p>WebSocket 建立连接的过程主要分为 <strong>​握手阶段</strong> 和 <strong>​数据传输阶段</strong></p><h3 id="一、握手阶段-http-upgrade-​" tabindex="-1">一、握手阶段（HTTP Upgrade）​ <a class="header-anchor" href="#一、握手阶段-http-upgrade-​" aria-label="Permalink to &quot;一、握手阶段（HTTP Upgrade）​&quot;">​</a></h3><p>WebSocket 连接通过 HTTP/HTTPS 协议发起，通过 Upgrade 头切换为 WebSocket 协议。</p><h5 id="_1、客户端请求-client-handshake-​" tabindex="-1">1、客户端请求（Client Handshake）​ <a class="header-anchor" href="#_1、客户端请求-client-handshake-​" aria-label="Permalink to &quot;1、客户端请求（Client Handshake）​&quot;">​</a></h5><p>客户端发送一个 HTTP GET 请求，包含以下关键头信息：</p><div class="language-http vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">GET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /chat </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">HTTP</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.1</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Host</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> example.com</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Upgrade</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> websocket          # 请求升级为 WebSocket 协议</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Connection</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Upgrade         # 表示需要升级连接</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Sec-WebSocket-Key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dGhlIHNhbXBsZSBub25jZQ==  # 随机生成的 Base64 密钥（16字节）</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Sec-WebSocket-Version</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 13   # WebSocket 协议版本（通常为 13）</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Origin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://example.com # 可选，用于安全校验</span></span></code></pre></div><h5 id="_2、服务端响应-server-handshake-​" tabindex="-1">2、服务端响应（Server Handshake）​ <a class="header-anchor" href="#_2、服务端响应-server-handshake-​" aria-label="Permalink to &quot;2、服务端响应（Server Handshake）​&quot;">​</a></h5><p>服务端验证请求后，返回 HTTP 101 Switching Protocols 响应：</p><div class="language-http vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">http</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">HTTP</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.1</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 101</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Switching Protocols</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Upgrade</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> websocket          # 确认协议升级</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Connection</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Upgrade</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">Sec-WebSocket-Accept</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> s3pPLMBiTxaQ9kYGzzhZRbK+xOo=  # 对客户端 Key 的校验值</span></span></code></pre></div><p><code>Sec-WebSocket-Accept</code> 生成规则： 将客户端的 <code>Sec-WebSocket-Key</code> 拼接固定 GUID <code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code>，然后计算 SHA-1 哈希，最后转为 <code>Base64</code>.</p><h3 id="二、连接建立" tabindex="-1">二、连接建立 <a class="header-anchor" href="#二、连接建立" aria-label="Permalink to &quot;二、连接建立&quot;">​</a></h3><p>握手成功后，TCP 连接保持打开状态，但协议从 HTTP 切换为 WebSocket。</p><p>后续所有通信通过 WebSocket 数据帧（Frame）传输，不再使用 HTTP。</p><h3 id="三、数据传输" tabindex="-1">三、数据传输 <a class="header-anchor" href="#三、数据传输" aria-label="Permalink to &quot;三、数据传输&quot;">​</a></h3><p>​数据帧格式：WebSocket 使用轻量级的二进制帧（Frame）传递数据，包含操作码（如文本/二进制）、掩码（客户端到服务端需掩码）、负载长度等。</p><p>​通信模式：全双工通信，客户端和服务端可随时主动发送消息。</p><h3 id="四、连接关闭" tabindex="-1">四、连接关闭 <a class="header-anchor" href="#四、连接关闭" aria-label="Permalink to &quot;四、连接关闭&quot;">​</a></h3><p>任一方发送关闭帧（Close Frame）即可终止连接：</p><h5 id="关键注意事项" tabindex="-1">关键注意事项 <a class="header-anchor" href="#关键注意事项" aria-label="Permalink to &quot;关键注意事项&quot;">​</a></h5><p>​跨域限制：受同源策略约束，可通过 Origin 头校验或 CORS 配置。</p><p>​加密：建议使用 wss://（WebSocket over TLS）保证安全。</p><p>​心跳机制：可通过 Ping/Pong 帧（操作码 0x9/0xA）保持连接活性。</p><h3 id="示例代码-客户端" tabindex="-1">示例代码：客户端 <a class="header-anchor" href="#示例代码-客户端" aria-label="Permalink to &quot;示例代码：客户端&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ws</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Websocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ws://xxx&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ws.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">open</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;连接已建立&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ws.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;msg&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, data: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;发送第一条消息&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ws.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onmessage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;收到服务端的消息&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, event.data)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ws.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onclose</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;连接已关闭&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ws.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onerror</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;报错&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h5 id="口诀速记" tabindex="-1">口诀速记 <a class="header-anchor" href="#口诀速记" aria-label="Permalink to &quot;口诀速记&quot;">​</a></h5><p>客户端带Key，服务端算Accept，101响应验明正身，然后开始聊天</p><div class="language-md vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">md</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&quot;一请求，二升级，三校验，四双工，五关闭&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">对应：</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">客户端发送HTTP升级请求</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">服务端返回101升级通过响应</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">密钥校验（Key/Accept）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">建立双工通信</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">关闭帧终止连接</span></span></code></pre></div><h2 id="readystate-状态检测" tabindex="-1">readyState 状态检测 <a class="header-anchor" href="#readystate-状态检测" aria-label="Permalink to &quot;readyState 状态检测&quot;">​</a></h2><p>readyState属性返回实例对象的当前状态，共有四种。</p><ul><li>CONNECTING：值为0，表示正在连接。</li><li>OPEN：值为1，表示连接成功，可以通信了。</li><li>CLOSING：值为2，表示连接正在关闭。</li><li>CLOSED：值为3，表示连接已经关闭，或者打开连接失败。</li></ul><h2 id="心跳检测的作用是什么" tabindex="-1">心跳检测的作用是什么 <a class="header-anchor" href="#心跳检测的作用是什么" aria-label="Permalink to &quot;心跳检测的作用是什么&quot;">​</a></h2><p>定期发送 Ping/Pong 帧，伪装成“活动流量”，欺骗中间设备保持连接。</p><p><strong>一句话记忆： 防设备掐线、防网络假活、防端口回收、防协议兼容</strong></p><h3 id="主要防止的问题" tabindex="-1">主要防止的问题 <a class="header-anchor" href="#主要防止的问题" aria-label="Permalink to &quot;主要防止的问题&quot;">​</a></h3><table tabindex="0"><thead><tr><th>问题类型</th><th>具体表现</th><th>心跳解决方案</th></tr></thead><tbody><tr><td>中间设备超时</td><td>Nginx/防火墙自动断开空闲连接</td><td>定期 Ping 维持&quot;活动&quot;状态</td></tr><tr><td>假连接（Zombie）</td><td>网络异常但 TCP 未及时断开</td><td>Ping 超时快速检测失效</td></tr><tr><td>移动网络/NAT 回收</td><td>运营商回收空闲端口导致连接失效</td><td>心跳间隔短于 NAT 超时时间</td></tr><tr><td>协议兼容性问题</td><td>某些设备不处理标准 Ping 帧</td><td>改用自定义文本心跳</td></tr></tbody></table><h2 id="手写一个简单的服务端-node-js-示例" tabindex="-1">手写一个简单的服务端（Node.js 示例） <a class="header-anchor" href="#手写一个简单的服务端-node-js-示例" aria-label="Permalink to &quot;手写一个简单的服务端（Node.js 示例）&quot;">​</a></h2><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Websocket</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ws&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 引入 websocket </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> server</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> WebSocket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Server</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({port: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个服务，设置端口</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 服务进行监听</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">server.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;connection&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">ws</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ws.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;message&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">message</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 收到客户端的消息，在这里回应</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`Received: \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">message</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ws.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">send</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`Echo: \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">message</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h2 id="和-http-的区别是什么" tabindex="-1">和 HTTP 的区别是什么？ <a class="header-anchor" href="#和-http-的区别是什么" aria-label="Permalink to &quot;和 HTTP 的区别是什么？&quot;">​</a></h2><p>关键点：协议升级、持久连接、双向通信、数据帧。</p><table tabindex="0"><thead><tr><th>关键区别</th><th>WebSocket</th><th>HTTP</th></tr></thead><tbody><tr><td>​<strong>协议升级</strong></td><td>通过HTTP握手升级为独立协议(101状态码)</td><td>始终保持HTTP协议</td></tr><tr><td>​<strong>连接方式</strong></td><td>持久长连接(单连接复用)</td><td>短连接(默认请求后关闭)</td></tr><tr><td>​<strong>通信模式</strong></td><td>全双工双向通信</td><td>半双工单向请求/响应</td></tr><tr><td>​<strong>数据传输格式</strong></td><td>二进制帧(头部仅2-14字节)</td><td>文本HTTP报文(头部臃肿)</td></tr></tbody></table><h2 id="如何保证低延迟" tabindex="-1">如何保证低延迟 <a class="header-anchor" href="#如何保证低延迟" aria-label="Permalink to &quot;如何保证低延迟&quot;">​</a></h2><p>要保证 WebSocket 的低延迟通信，需要从 ​网络层、协议层、服务端、客户端 全链路优化。</p><p><code>最优解 = 物理距离优化（按需） + 协议层优化（必选） + 代码级优化（必选）</code></p><h3 id="协议层优化" tabindex="-1">协议层优化 <a class="header-anchor" href="#协议层优化" aria-label="Permalink to &quot;协议层优化&quot;">​</a></h3><ul><li>使用二进制帧（如 Protocol Buffers）替代 JSON。</li><li>启用压缩（perMessageDeflate）。</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> wss</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> WebSocket.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Server</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  perMessageDeflate: { </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    threshold: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1024</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 1KB 以上数据压缩</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="​传输层优化" tabindex="-1">​传输层优化 <a class="header-anchor" href="#​传输层优化" aria-label="Permalink to &quot;​传输层优化&quot;">​</a></h3><p>启用 TCP Fast Open（减少握手 RTT）。</p><p>探索 QUIC 协议（HTTP/3 + WebSocket over QUIC）。</p><h3 id="​代码级优化" tabindex="-1">​代码级优化 <a class="header-anchor" href="#​代码级优化" aria-label="Permalink to &quot;​代码级优化&quot;">​</a></h3><p>异步非阻塞处理消息，避免主线程阻塞。</p><p>客户端使用 Web Worker 分离计算密集型任务。</p><h3 id="低延迟的四个核心原则" tabindex="-1">低延迟的四个核心原则： <a class="header-anchor" href="#低延迟的四个核心原则" aria-label="Permalink to &quot;低延迟的四个核心原则：&quot;">​</a></h3><ul><li>​短链路​（物理距离 + 高效协议）</li><li>轻数据​（压缩 + 二进制）</li><li>异步流​（非阻塞处理 + 多线程）</li><li>端智能​（客户端节流 + 分离计算）</li></ul><h2 id="如何检测是否已安装软件" tabindex="-1">如何检测是否已安装软件 <a class="header-anchor" href="#如何检测是否已安装软件" aria-label="Permalink to &quot;如何检测是否已安装软件&quot;">​</a></h2><ul><li>使用自定义协议（如果成功会存在弹窗）</li><li>通过socket 状态判断（只能检测是否已运行，需配合提示优化交互）</li></ul>`,59)]))}const g=i(h,[["render",e]]);export{o as __pageData,g as default};
