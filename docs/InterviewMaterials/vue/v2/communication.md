---
outline: [2,3]
---

# Vue2 组件通信

## 1、父子通信
父子组件通信是 Vue 开发中最常用的场景，主要包括 父传子 和 子传父 两种方向
  ### props（父 → 子）
  父组件通过props属性向子组件传递数据。
    - 单向数据流（子组件不能直接修改 props， props是只读的）。
    - 支持类型校验和默认值。

  ### $emit / v-on（子 → 父）
  子组件通过事件向父组件传递数据。
  - 自定义事件名（如 @update）。
  - 可携带参数。

  ### v-model（双向绑定语法糖）
  简化父子组件的双向数据绑定。
  - 父组件通过 v-model 传递数据。
  - 子组件通过 value prop 接收，通过 input 事件更新。

  ### ref（获取子组件实例）
    父组件通过访问子组件设置的ref， 直接 $refs 调用子组件的方法或访问数据。

  ### .sync 修饰符 (双向修改机制)
  - 父组件给子组件设置 .sync
  - 子组件 通过 $emit('update:prop', newValue) 修改父组件的数据。

  适用场景：
  - 场景 1：子组件需要修改父组件的某个状态（如开关、计数器、弹窗显隐）。
  - 场景 2：希望代码比 v-model 更语义化（明确绑定的是哪个属性）。

Vue3 中改用 v-model:prop，原理相同但语法更统一

## 2、兄弟通信
兄弟通信的核心思想： “通过第三方媒介传递数据”（父组件、事件总线、Vuex 均是媒介）。
### 通过共同的父组件（$emit → 父 → props）

### 事件总线（EventBus）
创建一个全局 Vue 实例作为事件中心，兄弟组件通过 $on 监听和 $emit 触发事件。

- 创建事件总线（通常单独放在一个文件中）： `export const EventBus = new Vue();`
- EventBus.$emit("message", "Data from BrotherA");
- EventBus.$on("message", (data) => {  })
- EventBus.$off("message"); `beforeDestroy 及时清理`

- 任意组件间的通信（兄弟、跨级、无关联组件）。
- 缺点：事件名需全局唯一，大型项目易混乱。

## 3、跨级通信
“跨级通信的核心是 找中介——要么通过父链（$attrs/provide），要么通过全局管家（事件总线/Vuex）。”

### $attrs / $listeners（透传属性和事件）
父组件作为中间层，需要透传属性和事件到深层子组件

优点
- ✅ 减少中间层代码：自动透传属性和事件，避免在中间组件手动传递 props 和 $emit。
- ✅ 灵活性强：适合封装高阶组件（如UI库的封装），支持动态属性和事件。
- ✅ 显式数据流：通过 v-bind="$attrs" 和 v-on="$listeners" 明确传递路径。

缺点
- ❌ 属性名冲突风险：如果透传的属性名与子组件已有的 props 或 data 冲突，可能导致意外行为。
- ❌ 无类型校验：$attrs 中的属性没有类型检查（不像 props 可以定义 type）。
- ❌ 需手动处理 class 和 style：默认会自动绑定到根元素，需设置 inheritAttrs: false 禁用。

### provide / inject（依赖注入）
祖先组件提供数据，任意后代组件注入使用（无需逐层传递）。

优点
- ✅ 跨任意层级通信：祖先组件提供数据，任意后代组件可直接注入，无视层级深度。
- ✅ 减少链式传递：避免 props 逐层传递的冗余代码。
- ✅ 适合全局配置：如主题、用户权限、语言包等全局数据。

缺点
- ❌ 数据来源不透明：后代组件无法直观看出数据来自哪个祖先，调试困难。
- ❌ 响应式限制：默认注入的数据不是响应式（需手动传入响应式对象或使用 computed）。
- ❌ 耦合性高：滥用会导致组件间隐式依赖，难以维护。


```
必须显式注入响应式对象（如 computed 或 Vue 实例）：
// 祖先组件
provide() {
  return {
    count: Vue.observable({ value: 0 }) // 或 this.count（如果是响应式数据）
  };
}
```
## 4、Vuex 通信


| 概念          | 作用                                                                 | 特点                                                                 |
|---------------|----------------------------------------------------------------------|----------------------------------------------------------------------|
| ​**State**     | 存储应用的状态数据（唯一数据源）                                     | 响应式，组件通过 `$store.state` 访问                                  |
| ​**Getters**   | 从 state 派生状态（类似计算属性）                                     | 通过 `$store.getters` 访问，结果可缓存                                |
| ​**Mutations** | 同步修改 state 的方法（唯一修改方式）                                 | 通过 `commit` 触发，支持状态变更追踪（如 devtools 调试）              |
| ​**Actions**   | 处理异步操作（如 API 请求），提交 mutations 修改 state              | 通过 `dispatch` 触发，可组合多个 mutations 或异步操作                  |
| ​**Modules**   | 将 store 分割为多个模块（适用于大型应用）                            | 每个模块独立管理 `state`、`mutations`、`actions`、`getters`，支持命名空间 |

